{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar crypt_1 = require(\"./crypt\");\nvar json_1 = require(\"./json\");\n/**\n * Decodes a Firebase auth. token into constituent parts.\n *\n * Notes:\n * - May return with invalid / incomplete claims if there's no native base64 decoding support.\n * - Doesn't check if the token is actually valid.\n *\n * @param {?string} token\n * @return {{header: *, claims: *, data: *, signature: string}}\n */\nexports.decode = function (token) {\n  var header = {},\n    claims = {},\n    data = {},\n    signature = '';\n  try {\n    var parts = token.split('.');\n    header = json_1.jsonEval(crypt_1.base64Decode(parts[0]) || '');\n    claims = json_1.jsonEval(crypt_1.base64Decode(parts[1]) || '');\n    signature = parts[2];\n    data = claims['d'] || {};\n    delete claims['d'];\n  } catch (e) {}\n  return {\n    header: header,\n    claims: claims,\n    data: data,\n    signature: signature\n  };\n};\n/**\n * Decodes a Firebase auth. token and checks the validity of its time-based claims. Will return true if the\n * token is within the time window authorized by the 'nbf' (not-before) and 'iat' (issued-at) claims.\n *\n * Notes:\n * - May return a false negative if there's no native base64 decoding support.\n * - Doesn't check if the token is actually valid.\n *\n * @param {?string} token\n * @return {boolean}\n */\nexports.isValidTimestamp = function (token) {\n  var claims = exports.decode(token).claims,\n    now = Math.floor(new Date().getTime() / 1000),\n    validSince,\n    validUntil;\n  if (typeof claims === 'object') {\n    if (claims.hasOwnProperty('nbf')) {\n      validSince = claims['nbf'];\n    } else if (claims.hasOwnProperty('iat')) {\n      validSince = claims['iat'];\n    }\n    if (claims.hasOwnProperty('exp')) {\n      validUntil = claims['exp'];\n    } else {\n      // token will expire after 24h by default\n      validUntil = validSince + 86400;\n    }\n  }\n  return now && validSince && validUntil && now >= validSince && now <= validUntil;\n};\n/**\n * Decodes a Firebase auth. token and returns its issued at time if valid, null otherwise.\n *\n * Notes:\n * - May return null if there's no native base64 decoding support.\n * - Doesn't check if the token is actually valid.\n *\n * @param {?string} token\n * @return {?number}\n */\nexports.issuedAtTime = function (token) {\n  var claims = exports.decode(token).claims;\n  if (typeof claims === 'object' && claims.hasOwnProperty('iat')) {\n    return claims['iat'];\n  }\n  return null;\n};\n/**\n * Decodes a Firebase auth. token and checks the validity of its format. Expects a valid issued-at time and non-empty\n * signature.\n *\n * Notes:\n * - May return a false negative if there's no native base64 decoding support.\n * - Doesn't check if the token is actually valid.\n *\n * @param {?string} token\n * @return {boolean}\n */\nexports.isValidFormat = function (token) {\n  var decoded = exports.decode(token),\n    claims = decoded.claims;\n  return !!decoded.signature && !!claims && typeof claims === 'object' && claims.hasOwnProperty('iat');\n};\n/**\n * Attempts to peer into an auth token and determine if it's an admin auth token by looking at the claims portion.\n *\n * Notes:\n * - May return a false negative if there's no native base64 decoding support.\n * - Doesn't check if the token is actually valid.\n *\n * @param {?string} token\n * @return {boolean}\n */\nexports.isAdmin = function (token) {\n  var claims = exports.decode(token).claims;\n  return typeof claims === 'object' && claims['admin'] === true;\n};","map":{"version":3,"names":["crypt_1","require","json_1","exports","decode","token","header","claims","data","signature","parts","split","jsonEval","base64Decode","e","isValidTimestamp","now","Math","floor","Date","getTime","validSince","validUntil","hasOwnProperty","issuedAtTime","isValidFormat","decoded","isAdmin"],"sources":["C:\\React\\employee\\node_modules\\@firebase\\util\\dist\\cjs\\src\\jwt.ts"],"sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { base64Decode } from './crypt';\nimport { jsonEval } from './json';\n\n/**\n * Decodes a Firebase auth. token into constituent parts.\n *\n * Notes:\n * - May return with invalid / incomplete claims if there's no native base64 decoding support.\n * - Doesn't check if the token is actually valid.\n *\n * @param {?string} token\n * @return {{header: *, claims: *, data: *, signature: string}}\n */\nexport const decode = function(token) {\n  var header = {},\n    claims = {},\n    data = {},\n    signature = '';\n\n  try {\n    var parts = token.split('.');\n    header = jsonEval(base64Decode(parts[0]) || '');\n    claims = jsonEval(base64Decode(parts[1]) || '');\n    signature = parts[2];\n    data = claims['d'] || {};\n    delete claims['d'];\n  } catch (e) {}\n\n  return {\n    header: header,\n    claims: claims,\n    data: data,\n    signature: signature\n  };\n};\n\n/**\n * Decodes a Firebase auth. token and checks the validity of its time-based claims. Will return true if the\n * token is within the time window authorized by the 'nbf' (not-before) and 'iat' (issued-at) claims.\n *\n * Notes:\n * - May return a false negative if there's no native base64 decoding support.\n * - Doesn't check if the token is actually valid.\n *\n * @param {?string} token\n * @return {boolean}\n */\nexport const isValidTimestamp = function(token) {\n  var claims = decode(token).claims,\n    now = Math.floor(new Date().getTime() / 1000),\n    validSince,\n    validUntil;\n\n  if (typeof claims === 'object') {\n    if (claims.hasOwnProperty('nbf')) {\n      validSince = claims['nbf'];\n    } else if (claims.hasOwnProperty('iat')) {\n      validSince = claims['iat'];\n    }\n\n    if (claims.hasOwnProperty('exp')) {\n      validUntil = claims['exp'];\n    } else {\n      // token will expire after 24h by default\n      validUntil = validSince + 86400;\n    }\n  }\n\n  return (\n    now && validSince && validUntil && now >= validSince && now <= validUntil\n  );\n};\n\n/**\n * Decodes a Firebase auth. token and returns its issued at time if valid, null otherwise.\n *\n * Notes:\n * - May return null if there's no native base64 decoding support.\n * - Doesn't check if the token is actually valid.\n *\n * @param {?string} token\n * @return {?number}\n */\nexport const issuedAtTime = function(token) {\n  var claims = decode(token).claims;\n  if (typeof claims === 'object' && claims.hasOwnProperty('iat')) {\n    return claims['iat'];\n  }\n  return null;\n};\n\n/**\n * Decodes a Firebase auth. token and checks the validity of its format. Expects a valid issued-at time and non-empty\n * signature.\n *\n * Notes:\n * - May return a false negative if there's no native base64 decoding support.\n * - Doesn't check if the token is actually valid.\n *\n * @param {?string} token\n * @return {boolean}\n */\nexport const isValidFormat = function(token) {\n  var decoded = decode(token),\n    claims = decoded.claims;\n\n  return (\n    !!decoded.signature &&\n    !!claims &&\n    typeof claims === 'object' &&\n    claims.hasOwnProperty('iat')\n  );\n};\n\n/**\n * Attempts to peer into an auth token and determine if it's an admin auth token by looking at the claims portion.\n *\n * Notes:\n * - May return a false negative if there's no native base64 decoding support.\n * - Doesn't check if the token is actually valid.\n *\n * @param {?string} token\n * @return {boolean}\n */\nexport const isAdmin = function(token) {\n  var claims = decode(token).claims;\n  return typeof claims === 'object' && claims['admin'] === true;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}
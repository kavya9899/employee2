{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar Deferred = /** @class */function () {\n  function Deferred() {\n    var _this = this;\n    this.promise = new Promise(function (resolve, reject) {\n      _this.resolve = resolve;\n      _this.reject = reject;\n    });\n  }\n  /**\n   * Our API internals are not promiseified and cannot because our callback APIs have subtle expectations around\n   * invoking promises inline, which Promises are forbidden to do. This method accepts an optional node-style callback\n   * and returns a node-style callback which will resolve or reject the Deferred's promise.\n   * @param {((?function(?(Error)): (?|undefined))| (?function(?(Error),?=): (?|undefined)))=} callback\n   * @return {!function(?(Error), ?=)}\n   */\n  Deferred.prototype.wrapCallback = function (callback) {\n    var _this = this;\n    return function (error, value) {\n      if (error) {\n        _this.reject(error);\n      } else {\n        _this.resolve(value);\n      }\n      if (typeof callback === 'function') {\n        // Attaching noop handler just in case developer wasn't expecting\n        // promises\n        _this.promise.catch(function () {});\n        // Some of our callbacks don't expect a value and our own tests\n        // assert that the parameter length is 1\n        if (callback.length === 1) {\n          callback(error);\n        } else {\n          callback(error, value);\n        }\n      }\n    };\n  };\n  return Deferred;\n}();\nexports.Deferred = Deferred;","map":{"version":3,"names":["Deferred","_this","promise","Promise","resolve","reject","prototype","wrapCallback","callback","error","value","catch","length","exports"],"sources":["C:\\React\\employee\\node_modules\\@firebase\\util\\dist\\cjs\\src\\deferred.ts"],"sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport class Deferred<R> {\n  promise: Promise<R>;\n  reject;\n  resolve;\n  constructor() {\n    this.promise = new Promise((resolve, reject) => {\n      this.resolve = resolve;\n      this.reject = reject;\n    });\n  }\n\n  /**\n   * Our API internals are not promiseified and cannot because our callback APIs have subtle expectations around\n   * invoking promises inline, which Promises are forbidden to do. This method accepts an optional node-style callback\n   * and returns a node-style callback which will resolve or reject the Deferred's promise.\n   * @param {((?function(?(Error)): (?|undefined))| (?function(?(Error),?=): (?|undefined)))=} callback\n   * @return {!function(?(Error), ?=)}\n   */\n  wrapCallback(callback?) {\n    return (error, value?) => {\n      if (error) {\n        this.reject(error);\n      } else {\n        this.resolve(value);\n      }\n      if (typeof callback === 'function') {\n        // Attaching noop handler just in case developer wasn't expecting\n        // promises\n        this.promise.catch(() => {});\n\n        // Some of our callbacks don't expect a value and our own tests\n        // assert that the parameter length is 1\n        if (callback.length === 1) {\n          callback(error);\n        } else {\n          callback(error, value);\n        }\n      }\n    };\n  }\n}\n"],"mappings":";;AAAA;;;;;;;;;;;;;;;;;;AAgBA,IAAAA,QAAA;EAIE,SAAAA,SAAA;IAAA,IAAAC,KAAA;IACE,IAAI,CAACC,OAAO,GAAG,IAAIC,OAAO,CAAC,UAACC,OAAO,EAAEC,MAAM;MACzCJ,KAAI,CAACG,OAAO,GAAGA,OAAO;MACtBH,KAAI,CAACI,MAAM,GAAGA,MAAM;IACtB,CAAC,CAAC;EACJ;EAEA;;;;;;;EAOAL,QAAA,CAAAM,SAAA,CAAAC,YAAY,GAAZ,UAAaC,QAAS;IAAtB,IAAAP,KAAA;IACE,OAAO,UAACQ,KAAK,EAAEC,KAAM;MACnB,IAAID,KAAK,EAAE;QACTR,KAAI,CAACI,MAAM,CAACI,KAAK,CAAC;MACpB,CAAC,MAAM;QACLR,KAAI,CAACG,OAAO,CAACM,KAAK,CAAC;MACrB;MACA,IAAI,OAAOF,QAAQ,KAAK,UAAU,EAAE;QAClC;QACA;QACAP,KAAI,CAACC,OAAO,CAACS,KAAK,CAAC,aAAO,CAAC,CAAC;QAE5B;QACA;QACA,IAAIH,QAAQ,CAACI,MAAM,KAAK,CAAC,EAAE;UACzBJ,QAAQ,CAACC,KAAK,CAAC;QACjB,CAAC,MAAM;UACLD,QAAQ,CAACC,KAAK,EAAEC,KAAK,CAAC;QACxB;MACF;IACF,CAAC;EACH,CAAC;EACH,OAAAV,QAAC;AAAD,CAxCA,CAwCC;AAxCYa,OAAA,CAAAb,QAAA,GAAAA,QAAA"},"metadata":{},"sourceType":"script","externalDependencies":[]}